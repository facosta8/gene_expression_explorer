proceso <- g$Ontology_Process
funcion <- g$Ontology_Function
texto <- paste(
'MOLECULAR FUNCTION',
funcion,
'CELLULAR COMPONENT',
componente,
'BIOLOGICAL PROCESS',
proceso,
sep = '\n'
)
list(nombre, secuencia, texto)
}
info_gen(genes[50], gen_db)
info_gen <- function(id, db) {
g <- db[db$ID == id, ]
secuencia <- g$SEQUENCE
nombre <- g$Definition
componente <- g$Ontology_Component
proceso <- g$Ontology_Process
funcion <- g$Ontology_Function
texto <- paste(
'MOLECULAR FUNCTION',
funcion,
'CELLULAR COMPONENT',
componente,
'BIOLOGICAL PROCESS',
proceso,
collapse = '\n'
)
list(nombre, secuencia, texto)
}
info_gen(genes[50], gen_db)
info_gen <- function(id, db) {
g <- db[db$ID == id, ]
secuencia <- g$SEQUENCE
nombre <- g$Definition
componente <- g$Ontology_Component
proceso <- g$Ontology_Process
funcion <- g$Ontology_Function
texto <- paste(
'MOLECULAR FUNCTION',
funcion,
'CELLULAR COMPONENT',
componente,
'BIOLOGICAL PROCESS\n',
proceso,
collapse = '\n'
)
list(nombre, secuencia, texto)
}
info_gen(genes[50], gen_db)
paste0('hola, mi nombre es\n', 'Pepe')
paste0("hola, mi nombre es\n", "Pepe")
sprintf("hola, mi nombre es\n", "Pepe")
?sprintf
info_gen <- function(id, db) {
g <- db[db$ID == id, ]
secuencia <- g$SEQUENCE
nombre <- g$Definition
componente <- g$Ontology_Component
proceso <- g$Ontology_Process
funcion <- g$Ontology_Function
# texto <- paste(
#     'MOLECULAR FUNCTION',
#     funcion,
#     'CELLULAR COMPONENT',
#     componente,
#     'BIOLOGICAL PROCESS\n',
#     proceso,
#     collapse = '\n'
# )
list(nombre, secuencia, funcion, componente, proceso)
}
info_gen(genes[50], gen_db)
leer_opciones <- function(uids) {
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
print(b[1])
print(b[2])
print('#####################')
Sys.sleep(1)
}
}
listar_opciones('diabetes', 8)
a <- listar_opciones('diabetes', 8)
a
leer_opciones(a)
ver_sumario <- function(uid) {
base <-
'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?'
db <- 'db=gds'
id <- glue('&id={uid}')
url <- paste0(base, db, id)
download.file(url, 'q.xml')
results <- xmlToList(xmlParse('q.xml'))
titulo <- results$DocSum[4]$Item$text
descripcion <- results$DocSum[5]$Item$text
c(titulo, descripcion)
}
leer_opciones <- function(uids) {
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
print(b[1])
print(b[2])
print('#####################')
Sys.sleep(1)
}
}
leer_opciones(a)
?data.frame
data.frame(title = character(), desc = character())
leer_opciones <- function(uids) {
df <- data.frame(title = character(), desc = character())
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
df$title[i] <- b[1]
df$desc[i] <- b[2]
Sys.sleep(1)
}
df
}
leer_opciones(a)
leer_opciones <- function(uids) {
df <- data.frame(title = rep('na', length(uids)),
desc = rep('na', length(uids)))
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
df$title[i] <- b[1]
df$desc[i] <- b[2]
Sys.sleep(1)
}
df
}
leer_opciones(a)
warnings()
df <- data.frame(title = rep(' ', length(uids)),
desc = rep(' ', length(uids)))
df <- data.frame(title = rep(' ', length(a)),
desc = rep(' ', length(a)))
df
str(df)
leer_opciones <- function(uids) {
df <- data.frame(title = rep(' ', length(uids)),
desc = rep(' ', length(uids)),
stringsAsFactors = FALSE)
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
df$title[i] <- b[1]
df$desc[i] <- b[2]
Sys.sleep(1)
}
df
}
leer_opciones(a)
?download.file
ver_sumario <- function(uid) {
base <-
'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?'
db <- 'db=gds'
id <- glue('&id={uid}')
url <- paste0(base, db, id)
download.file(url, 'q.xml', quiet = TRUE)
results <- xmlToList(xmlParse('q.xml'))
titulo <- results$DocSum[4]$Item$text
descripcion <- results$DocSum[5]$Item$text
c(titulo, descripcion)
}
leer_opciones <- function(uids) {
df <- data.frame(title = rep(' ', length(uids)),
desc = rep(' ', length(uids)),
stringsAsFactors = FALSE)
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
df$title[i] <- b[1]
df$desc[i] <- b[2]
Sys.sleep(1)
}
df
}
leer_opciones <- function(uids) {
df <- data.frame(title = rep(' ', length(uids)),
desc = rep(' ', length(uids)),
stringsAsFactors = FALSE)
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
df$title[i] <- b[1]
df$desc[i] <- b[2]
Sys.sleep(0.5)
}
df
}
b <- leer_opciones(a)
View(b)
install.packages(c("forecast", "RcppArmadillo"))
leer_opciones <- function(uids) {
df <- data.frame(id = rep(' ', length(uids)),
title = rep(' ', length(uids)),
desc = rep(' ', length(uids)),
stringsAsFactors = FALSE)
for (i in seq(uids)) {
b <- ver_sumario(uids[i])
df$id[i] <- uids[i]
df$title[i] <- b[1]
df$desc[i] <- b[2]
Sys.sleep(0.5)
}
df
}
b <- leer_opciones(a)
View(b)
library(shiny)
source('geo_api.R')
?setBookmarkExclude
?setwd
getwd()
setwd(.)
this.dir <- dirname(parent.frame(2)$ofile)
setwd(this.dir)
this.dir <- dirname(parent.frame(2)$ofile)
?dirname
dirname()
parent.frame(2)
parent.frame()
parent.frame(1)
parent.frame(3)
?parent.frame
parent.frame(2)$ofile
parent.frame(3)$ofile
parent.frame(-1)$ofile
?file.path
file.path()
file.path(getwd())
this_dir <- function(directory)
setwd( file.path(getwd(), directory) )
this_dir()
file.path('..')
file.path('..', 'cpath')
getwd()
dir <- dirname(parent.frame(2)$ofile)
parent.frame(2)$ofile
parent.frame
parent.frame()
parent.frame(1)
parent.frame(2)
parent.frame(3)
parent.frame(8)
a <- parent.frame(3)
a
str(a)
library(here)
install.packages("here")
source('C:/Users/facosta8/giteando/gene_expression_explorer/shiny/app.R', echo=TRUE)
source('C:/Users/facosta8/giteando/gene_expression_explorer/shiny/app.R', echo=TRUE)
source('C:/Users/facosta8/giteando/gene_expression_explorer/shiny/app.R', echo=TRUE)
source('C:/Users/facosta8/giteando/gene_expression_explorer/ejemplo/aleatorio.R', echo=TRUE)
??drop_na
source('C:/Users/facosta8/giteando/gene_expression_explorer/ejemplo/aleatorio.R', echo=TRUE)
View(dd)
head(dd)
#######################################
### Aplicacion
# si quieren hacer una prueba chica, pueden hacer un muestreo
#mm <- head(m, 2000)
mm <- m
t <- 200  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 10
b <- 25   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
# creamos la lista con todas las funciones hash
lista <- replicate(t, crear_hash(v, delta))
# la aplicamos a todos los elementos
c <- sapply(lista, function(x) apply(mm, MARGIN=1, x))
# creamos las cubetas
cc <- t(apply(c, MARGIN=1, crear_cubetas, n_cubetas=b))
# agrupamos por cubetas
d <- as_tibble(cc, rownames='gen') %>%
gather('v', 'cubeta', -gen) %>%
select(-v) %>%
group_by(cubeta) %>%
summarise(n_elementos = n(),
candidatos = list(gen)) %>%
arrange(desc(n_elementos))
# eliminamos las cubetas de un elemento
dd <- filter(d, n_elementos > 1)
View(dd)
t <- 200  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 10
b <- 20   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
# creamos la lista con todas las funciones hash
lista <- replicate(t, crear_hash(v, delta))
# la aplicamos a todos los elementos
c <- sapply(lista, function(x) apply(mm, MARGIN=1, x))
# creamos las cubetas
cc <- t(apply(c, MARGIN=1, crear_cubetas, n_cubetas=b))
# agrupamos por cubetas
d <- as_tibble(cc, rownames='gen') %>%
gather('v', 'cubeta', -gen) %>%
select(-v) %>%
group_by(cubeta) %>%
summarise(n_elementos = n(),
candidatos = list(gen)) %>%
arrange(desc(n_elementos))
# eliminamos las cubetas de un elemento
dd <- filter(d, n_elementos > 1)
head(dd)
t <- 160  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 10
b <- 20   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 80  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 10
b <- 16   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 120  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 10
b <- 20   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 120  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 10
b <- 15   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 120  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 15   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 120  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 12   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 120  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 20   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 125  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 25   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 150  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 25   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
print('hola')
t <- 125  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 25   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
t <- 125  # numero de funciones hash
# tamaño de cada segmento en mi hiperplano. Determina las distancias
# en mi familia
delta <- 6
b <- 25   # numero de cubetas
v <- ncol(mm)  # tamaño de cada vector
r <- t/b  # elementos por cubeta
# definición de la familia
glue::glue(
'Con esta familia, si tenemos una distancia menor
o igual a {delta/2}, la probabilidad de que las
secuencias tengan el mismo hash es {1-(1-(0.5^r))^b}.
Si la distancia es mayor a a {delta*2}, la probabilidad de
que tengan el  mismo hash es menor a {1-(1-((1/3)^r))^b}'
)
# creamos la lista con todas las funciones hash
lista <- replicate(t, crear_hash(v, delta))
# la aplicamos a todos los elementos
c <- sapply(lista, function(x) apply(mm, MARGIN=1, x))
# creamos las cubetas
cc <- t(apply(c, MARGIN=1, crear_cubetas, n_cubetas=b))
# agrupamos por cubetas
d <- as_tibble(cc, rownames='gen') %>%
gather('v', 'cubeta', -gen) %>%
select(-v) %>%
group_by(cubeta) %>%
summarise(n_elementos = n(),
candidatos = list(gen)) %>%
arrange(desc(n_elementos))
# eliminamos las cubetas de un elemento
dd <- filter(d, n_elementos > 1)
head(dd)
